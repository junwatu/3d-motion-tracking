<!DOCTYPE html>
<html>

<head>
	<title>3D Object Movement Simulation</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}
	</style>
</head>

<body>
	<script src="https://threejs.org/build/three.js"></script>
	<!-- Include the AHRS library -->
	<script src="/www-ahrs.js"></script>
	<script>
		window.onload = function () {
			let scene, camera, renderer, object3D;
			let madgwick;
			let previousQuaternion = new THREE.Quaternion();  // Store the previous quaternion
			let lerpFactor = 0.02;  // Adjust this value to control the smoothness


			function init() {
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				const geometry = new THREE.BoxGeometry();
				const materials = [
					new THREE.MeshStandardMaterial({ color: 0xff3333 }), // Red
					// Continue with different materials for each face
					new THREE.MeshStandardMaterial({ color: 0x33ff33 }), // Green
					new THREE.MeshStandardMaterial({ color: 0x3333ff }), // Blue
					new THREE.MeshStandardMaterial({ color: 0xffff33 }), // Yellow
					new THREE.MeshStandardMaterial({ color: 0x33ffff }), // Cyan
					new THREE.MeshStandardMaterial({ color: 0xff33ff })  // Magenta
				];

				object3D = new THREE.Mesh(geometry, materials); // Apply the materials to the cube
				scene.add(object3D);

				// Add ambient light
				const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
				scene.add(ambientLight);

				// Add directional light
				const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // White directional light
				directionalLight.position.set(0, 1, 0); // Position the light above the cube
				scene.add(directionalLight);

				camera.position.z = 5;

				// Initialize Madgwick filter for sensor fusion
				madgwick = new AHRS({
					sampleInterval: 115200, // Adjust this based on your sensor's sampling rate
					algorithm: 'Madgwick',
					beta: 0.1 // Adjust this parameter based on trial and error for stability vs responsiveness
				});

				console.log(madgwick.get)

				// Setup WebSocket
				const socket = new WebSocket('ws://localhost:3000');
				socket.onmessage = function (event) {
					const sensorData = JSON.parse(event.data);
					const quaternion = processSensorData(sensorData);
					object3D.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
				};

				animate();
			}

			function processSensorData(data) {
				// Normalize accelerometer data (±4g FSR)
				const accel = {
					x: data.accel.x / 8192.0,
					y: data.accel.y / 8192.0,
					z: data.accel.z / 8192.0
				};

				// Normalize gyro data (±1000°/s FSR)
				const gyro = {
					x: (data.gyro.x / 32.8) * (Math.PI / 180),
					y: (data.gyro.y / 32.8) * (Math.PI / 180),
					z: (data.gyro.z / 32.8) * (Math.PI / 180)
				};

				// Assuming magnetometer data is fine as is, or add your own calibration logic
				const mag = {
					x: data.mag.x + 200,
					y: data.mag.y - 70,
					z: data.mag.z - 700
				};

				// Update Madgwick filter with current sensor data
				madgwick.update(
					data.gyro.x, data.gyro.y, data.gyro.z, // Gyro data in radians per second
					data.accel.x, data.accel.y, data.accel.z, // Accelerometer data in g's
					data.mag.x, data.mag.y, data.mag.z // Magnetometer data
				);

				// Get quaternion from Madgwick filter
				const newQuaternion = madgwick.getQuaternion();
				// Lerp (Linear Interpolation) for smooth transition
				previousQuaternion.slerp(new THREE.Quaternion(newQuaternion.x, newQuaternion.y, newQuaternion.z, newQuaternion.w), lerpFactor);

				// Update the object's quaternion
				object3D.quaternion.copy(previousQuaternion);

				// Save the new quaternion as the previous one for the next frame
				previousQuaternion.copy(object3D.quaternion);
				// Return quaternion as THREE.Quaternion
				return object3D.quaternion;
			}

			function animate() {
				requestAnimationFrame(animate);
				renderer.render(scene, camera);
			}

			// Initialize the scene
			init();
		};
	</script>
</body>

</html>